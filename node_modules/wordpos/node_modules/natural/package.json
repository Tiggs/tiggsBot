{
  "name": "natural",
  "description": "General natural language (tokenizing, stemming (English, Russian, Spanish), classification, inflection, phonetics, tfidf, WordNet, jaro-winkler, Levenshtein distance, Dice's Coefficient) facilities for node.",
  "version": "0.2.1",
  "homepage": "https://github.com/NaturalNode/natural",
  "repository": {
    "type": "git",
    "url": "git://github.com/NaturalNode/natural.git"
  },
  "engines": {
    "node": ">=0.4.10"
  },
  "dependencies": {
    "sylvester": ">= 0.0.12",
    "apparatus": ">= 0.0.9",
    "underscore": ">=1.3.1"
  },
  "devDependencies": {
    "uubench": "0.0.x",
    "jasmine-node": "~1.13.1"
  },
  "scripts": {
    "test": "NODE_PATH=. node_modules/jasmine-node/bin/jasmine-node spec/"
  },
  "license": "MIT",
  "author": {
    "name": "Chris Umbel",
    "email": "chris@chrisumbel.com"
  },
  "keywords": [
    "natural",
    "language",
    "porter",
    "lancaster",
    "stemmer",
    "bayes",
    "classifier",
    "phonetic",
    "metaphone",
    "inflector",
    "wordnet",
    "tf-idf",
    "logistic",
    "regression",
    "doublemetaphone",
    "double",
    "jaro-winkler",
    "levenshtein",
    "distance"
  ],
  "main": "./lib/natural/index.js",
  "maintainers": [
    {
      "name": "Chris Umbel",
      "email": "chris@chrisumbel.com",
      "url": "http://www.chrisumbel.com"
    },
    {
      "name": "Rob Ellis",
      "email": "rob@silentrob.me"
    },
    {
      "name": "Ken Koch",
      "email": "kkoch986@gmail.com"
    }
  ],
  "gitHead": "7621accaa19abf5bc8140c81c9ec4db0a00ff5f8",
  "readme": "natural\r\n=======\r\n\r\n[![Build Status](https://travis-ci.org/NaturalNode/natural.png?branch=master)](https://travis-ci.org/NaturalNode/natural)\r\n\r\n\"Natural\" is a general natural language facility for nodejs. Tokenizing,\r\nstemming, classification, phonetics, tf-idf, WordNet, string similarity,\r\nand some inflections are currently supported.\r\n\r\nIt's still in the early stages, so we're very interested in bug reports,\r\ncontributions and the like.\r\n\r\nNote that many algorithms from Rob Ellis's [node-nltools](https://github.com/NaturalNode/node-nltools) are\r\nbeing merged into this project and will be maintained from here onward.\r\n\r\nAt the moment, most of the algorithms are English-specific, but in the long-term, some diversity\r\nwill be in order. Thanks to Polyakov Vladimir, Russian stemming has been added!, Thanks to David Przybilla, Spanish stemming has been added!.\r\n\r\nAside from this README, the only documentation is [this DZone article](http://www.dzone.com/links/r/using_natural_a_nlp_module_for_nodejs.html) and [here on my blog](http://www.chrisumbel.com/article/node_js_natural_language_porter_stemmer_lancaster_bayes_naive_metaphone_soundex), which is a bit older.\r\n\r\nInstallation\r\n------------\r\n\r\nIf you're just looking to use natural without your own node application,\r\nyou can install via NPM like so:\r\n\r\n    npm install natural\r\n\r\nIf you're interested in contributing to natural, or just hacking on it, then by all\r\nmeans fork away!\r\n\r\nTokenizers\r\n----------\r\n\r\nWord, Regexp, and [Treebank tokenizers](http://www.cis.upenn.edu/~treebank/tokenization.html) are provided for breaking text up into\r\narrays of tokens:\r\n\r\n```javascript\r\nvar natural = require('natural'),\r\n  tokenizer = new natural.WordTokenizer();\r\nconsole.log(tokenizer.tokenize(\"your dog has fleas.\"));\r\n// [ 'your', 'dog', 'has', 'fleas' ]\r\n```\r\n\r\nThe other tokenizers follow a similar pattern:\r\n\r\n```javascript\r\ntokenizer = new natural.TreebankWordTokenizer();\r\nconsole.log(tokenizer.tokenize(\"my dog hasn't any fleas.\"));\r\n// [ 'my', 'dog', 'has', 'n\\'t', 'any', 'fleas', '.' ]\r\n\r\ntokenizer = new natural.RegexpTokenizer({pattern: /\\-/});\r\nconsole.log(tokenizer.tokenize(\"flea-dog\"));\r\n// [ 'flea', 'dog' ]\r\n\r\ntokenizer = new natural.WordPunctTokenizer();\r\nconsole.log(tokenizer.tokenize(\"my dog hasn't any fleas.\"));\r\n// [ 'my',  'dog',  'hasn',  '\\'',  't',  'any',  'fleas',  '.' ]\r\n```\r\n\r\nString Distance\r\n----------------------\r\nNatural provides an implementation of the [Jaro–Winkler](http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance) string distance measuring algorithm.\r\nThis will return a number between 0 and 1 which tells how closely the strings match (0 = not at all, 1 = exact match):\r\n\r\n```javascript\r\nvar natural = require('natural');\r\nconsole.log(natural.JaroWinklerDistance(\"dixon\",\"dicksonx\"))\r\nconsole.log(natural.JaroWinklerDistance('not', 'same'));\r\n```\r\n\r\nOutput:\r\n\r\n```javascript\r\n0.7466666666666666\r\n0\r\n```\r\n\r\nNatural also offers support for Levenshtein distances:\r\n\r\n```javascript\r\nvar natural = require('natural');\r\nconsole.log(natural.LevenshteinDistance(\"ones\",\"onez\"));\r\nconsole.log(natural.LevenshteinDistance('one', 'one'));\r\n```\r\n\r\nOutput:\r\n\r\n```javascript\r\n1\r\n0\r\n```\r\n\r\nThe cost of the three edit operations are modifiable for Levenshtein:\r\n\r\n```javascript\r\nconsole.log(natural.LevenshteinDistance(\"ones\",\"onez\", {\r\n    insertion_cost: 1,\r\n    deletion_cost: 1,\r\n    substitution_cost: 1\r\n}));\r\n```\r\n\r\nOutput:\r\n\r\n```javascript\r\n1\r\n```\r\n\r\nAnd Dice's co-efficient:\r\n\r\n```javascript\r\nvar natural = require('natural');\r\nconsole.log(natural.DiceCoefficient('thing', 'thing'));\r\nconsole.log(natural.DiceCoefficient('not', 'same'));\r\n```\r\n\r\nOutput:\r\n\r\n```javascript\r\n1\r\n0\r\n```\r\n\r\nStemmers\r\n--------\r\n\r\nCurrently stemming is supported via the [Porter](http://tartarus.org/martin/PorterStemmer/index.html) and [Lancaster](http://www.comp.lancs.ac.uk/computing/research/stemming/) (Paice/Husk) algorithms.\r\n\r\n```javascript\r\nvar natural = require('natural');\r\n```\r\n\r\nThis example uses a Porter stemmer. \"word\" is returned.\r\n\r\n```javascript\r\nconsole.log(natural.PorterStemmer.stem(\"words\")); // stem a single word\r\n```\r\n\r\n in Russian:\r\n\r\n```javascript\r\nconsole.log(natural.PorterStemmerRu.stem(\"падший\"));\r\n```\r\n\r\n in Spanish:\r\n\r\n```javascript\r\nconsole.log(natural.PorterStemmerEs.stem(\"jugaría\"));\r\n```\r\n\r\n`attach()` patches `stem()` and `tokenizeAndStem()` to String as a shortcut to\r\n`PorterStemmer.stem(token)`. `tokenizeAndStem()` breaks text up into single words\r\nand returns an array of stemmed tokens.\r\n\r\n```javascript\r\nnatural.PorterStemmer.attach();\r\nconsole.log(\"i am waking up to the sounds of chainsaws\".tokenizeAndStem());\r\nconsole.log(\"chainsaws\".stem());\r\n```\r\n\r\nthe same thing can be done with a Lancaster stemmer:\r\n\r\n```javascript\r\nnatural.LancasterStemmer.attach();\r\nconsole.log(\"i am waking up to the sounds of chainsaws\".tokenizeAndStem());\r\nconsole.log(\"chainsaws\".stem());\r\n```\r\n\r\nClassifiers\r\n----------------------\r\n\r\nTwo classifiers are currently supported, [Naive Bayes](http://en.wikipedia.org/wiki/Naive_Bayes_classifier) and [logistic regression](http://en.wikipedia.org/wiki/Logistic_regression).\r\nThe following examples use the BayesClassifier class, but the \r\nLogisticRegressionClassifier class could be substituted instead.\r\n\r\n```javascript\r\nvar natural = require('natural'),\r\n  classifier = new natural.BayesClassifier();\r\n```\r\n\r\nYou can train the classifier on sample text. It will use reasonable defaults to\r\ntokenize and stem the text.\r\n\r\n```javascript\r\nclassifier.addDocument('i am long qqqq', 'buy');\r\nclassifier.addDocument('buy the q\\'s', 'buy');\r\nclassifier.addDocument('short gold', 'sell');\r\nclassifier.addDocument('sell gold', 'sell');\r\n\r\nclassifier.train();\r\n```\r\n\r\nOutputs \"sell\"\r\n\r\n```javascript\r\nconsole.log(classifier.classify('i am short silver'));\r\n```\r\n\r\nOutputs \"buy\"\r\n\r\n```javascript\r\nconsole.log(classifier.classify('i am long copper'));\r\n```\r\n\r\nYou have access to the set of matched classes and the associated value from the classifier.\r\n\r\nOutputs:\r\n\r\n```javascript\r\n[ { label: 'buy', value: 0.39999999999999997 },\r\n  { label: 'sell', value: 0.19999999999999998 } ]\r\n```\r\n\r\nFrom this:\r\n\r\n```javascript\r\nconsole.log(classifier.getClassifications('i am long copper'));\r\n```\r\n\r\nThe classifier can also be trained with and can classify arrays of tokens, strings, or\r\nany mixture of the two. Arrays let you use entirely custom data with your own\r\ntokenization/stemming, if you choose to implement it.\r\n\r\n```javascript\r\nclassifier.addDocument(['sell', 'gold'], 'sell');\r\n```\r\n\r\nThe training process can be monitored by subscribing to the event `trainedWithDocument` that's emitted by the classifier, this event's emitted each time a document is finished being trained against:\r\n\r\n    classifier.events.on('trainedWithDocument', function (obj) {\r\n       console.log(obj);\r\n       /* {\r\n       *   total: 23 // There are 23 total documents being trained against\r\n       *   index: 12 // The index/number of the document that's just been trained against\r\n       *   doc: {...} // The document that has just been indexed\r\n       */ }\r\n    });\r\n\r\nA classifier can also be persisted and recalled so you can reuse a training\r\n\r\n```javascript\r\nclassifier.save('classifier.json', function(err, classifier) {\r\n    // the classifier is saved to the classifier.json file!\r\n});\r\n```\r\n\r\nTo recall from the classifier.json saved above:\r\n\r\n```javascript\r\nnatural.BayesClassifier.load('classifier.json', null, function(err, classifier) {\r\n    console.log(classifier.classify('long SUNW'));\r\n    console.log(classifier.classify('short SUNW'));\r\n});\r\n```\r\n\r\nA classifier can also be serialized and deserialized like so:\r\n\r\n```javascript\r\nvar classifier = new natural.BayesClassifier();\r\nclassifier.addDocument(['sell', 'gold'], 'sell');\r\nclassifier.addDocument(['buy', 'silver'], 'buy');\r\n\r\n// serialize\r\nvar raw = JSON.stringify(classifier);\r\n// deserialize\r\nvar restoredClassifier = natural.BayesClassifier.restore(JSON.parse(raw));\r\nconsole.log(restoredClassifier.classify('i should sell that'));\r\n```\r\n\r\nPhonetics\r\n---------\r\n\r\nPhonetic matching (sounds-like) matching can be done with the [SoundEx](http://en.wikipedia.org/wiki/Soundex),\r\n[Metaphone](http://en.wikipedia.org/wiki/Metaphone) or [DoubleMetaphone](http://en.wikipedia.org/wiki/Metaphone#Double_Metaphone) algorithms\r\n\r\n```javascript\r\nvar natural = require('natural'),\r\n    metaphone = natural.Metaphone, soundEx = natural.SoundEx;\r\n\r\nvar wordA = 'phonetics';\r\nvar wordB = 'fonetix';\r\n```\r\n\r\nTo test the two words to see if they sound alike:\r\n\r\n```javascript\r\nif(metaphone.compare(wordA, wordB))\r\n    console.log('they sound alike!');\r\n```\r\n\r\nThe raw phonetics are obtained with `process()`:\r\n\r\n```javascript\r\nconsole.log(metaphone.process('phonetics'));\r\n```\r\n\r\nA maximum code length can be supplied:\r\n\r\n```javascript\r\nconsole.log(metaphone.process('phonetics', 3));\r\n```\r\n\r\n`DoubleMetaphone` deals with two encodings returned in an array. This\r\nfeature is experimental and subject to change:\r\n\r\n```javascript\r\nvar natural = require('natural'),\r\n  dm = natural.DoubleMetaphone;\r\n\r\nvar encodings = dm.process('Matrix');\r\nconsole.log(encodings[0]);\r\nconsole.log(encodings[1]);\r\n```\r\n\r\nAttaching will patch String with useful methods:\r\n\r\n```javascript\r\nmetaphone.attach();\r\n```\r\n\r\n`soundsLike` is essentially a shortcut to `Metaphone.compare`:\r\n\r\n```javascript\r\nif(wordA.soundsLike(wordB))\r\n    console.log('they sound alike!');\r\n```\r\n\r\nThe raw phonetics are obtained with `phonetics()`:\r\n\r\n```javascript\r\nconsole.log('phonetics'.phonetics());\r\n```\r\n\r\nFull text strings can be tokenized into arrays of phonetics (much like how tokenization-to-arrays works for stemmers):\r\n\r\n```javascript\r\nconsole.log('phonetics rock'.tokenizeAndPhoneticize());\r\n```\r\n\r\nSame module operations applied with `SoundEx`:\r\n\r\n```javascript\r\nif(soundEx.compare(wordA, wordB))\r\n    console.log('they sound alike!');\r\n```\r\n\r\nThe same String patches apply with `soundEx`:\r\n\r\n```javascript\r\nsoundEx.attach();\r\n\r\nif(wordA.soundsLike(wordB))\r\n    console.log('they sound alike!');\r\n\r\nconsole.log('phonetics'.phonetics());\r\n```\r\n\r\nInflectors\r\n----------\r\n\r\n### Nouns\r\n\r\nNouns can be pluralized/singularized with a `NounInflector`:\r\n\r\n```javascript\r\nvar natural = require('natural'),\r\nnounInflector = new natural.NounInflector();\r\n```\r\n\r\nTo pluralize a word (outputs \"radii\"):\r\n\r\n```javascript\r\nconsole.log(nounInflector.pluralize('radius'));\r\n```\r\n\r\nTo singularize a word (outputs \"beer\"):\r\n\r\n```javascript\r\nconsole.log(nounInflector.singularize('beers'));\r\n```\r\n\r\nLike many of the other features, String can be patched to perform the operations\r\ndirectly. The \"Noun\" suffix on the methods is necessary, as verbs will be\r\nsupported in the future.\r\n\r\n```javascript\r\nnounInflector.attach();\r\nconsole.log('radius'.pluralizeNoun());\r\nconsole.log('beers'.singularizeNoun());\r\n```\r\n\r\n### Numbers\r\n\r\nNumbers can be counted with a CountInflector:\r\n\r\n```javascript\r\nvar countInflector = natural.CountInflector;\r\n```\r\n\r\nOutputs \"1st\":\r\n\r\n```javascript\r\nconsole.log(countInflector.nth(1));\r\n```\r\n\r\nOutputs \"111th\":\r\n\r\n```javascript\r\nconsole.log(countInflector.nth(111));\r\n```\r\n\r\n### Present Tense Verbs\r\n\r\nPresent Tense Verbs can be pluralized/singularized with a PresentVerbInflector.\r\nThis feature is still experimental as of 0.0.42, so use with caution, and please\r\nprovide feedback.\r\n\r\n```javascript\r\nvar verbInflector = new natural.PresentVerbInflector();\r\n```\r\n\r\nOutputs \"becomes\":\r\n\r\n```javascript\r\nconsole.log(verbInflector.singularize('become'));\r\n```\r\n\r\nOutputs \"become\":\r\n\r\n```javascript\r\nconsole.log(verbInflector.pluralize('becomes'));\r\n```\r\n\r\nLike many other natural modules, `attach()` can be used to patch strings with\r\nhandy methods.\r\n\r\n```javascript\r\nverbInflector.attach();\r\nconsole.log('walk'.singularizePresentVerb());\r\nconsole.log('walks'.pluralizePresentVerb());\r\n```\r\n\r\n\r\nN-Grams\r\n-------\r\n\r\nn-grams can be obtained for either arrays or strings (which will be tokenized\r\nfor you):\r\n\r\n```javascript\r\nvar NGrams = natural.NGrams;\r\n```\r\n\r\n### bigrams\r\n\r\n```javascript\r\nconsole.log(NGrams.bigrams('some words here'));\r\nconsole.log(NGrams.bigrams(['some',  'words',  'here']));\r\n```\r\n\r\nBoth of the above output: `[ [ 'some', 'words' ], [ 'words', 'here' ] ]`\r\n\r\n### trigrams\r\n\r\n```javascript\r\nconsole.log(NGrams.trigrams('some other words here'));\r\nconsole.log(NGrams.trigrams(['some',  'other', 'words',  'here']));\r\n```\r\n\r\nBoth of the above output: `[ [ 'some', 'other', 'words' ],\r\n  [ 'other', 'words', 'here' ] ]`\r\n\r\n### arbitrary n-grams\r\n\r\n```javascript\r\nconsole.log(NGrams.ngrams('some other words here for you', 4));\r\nconsole.log(NGrams.ngrams(['some', 'other', 'words', 'here', 'for',\r\n    'you'], 4));\r\n```\r\n\r\nThe above outputs: `[ [ 'some', 'other', 'words', 'here' ],\r\n  [ 'other', 'words', 'here', 'for' ],\r\n  [ 'words', 'here', 'for', 'you' ] ]`\r\n\r\n### padding\r\n\r\nn-grams can also be returned with left or right padding by passing a start and/or end symbol to the bigrams, trigrams or ngrams.\r\n\r\n```javascript\r\nconsole.log(NGrams.ngrams('some other words here for you', 4, '[start]', '[end]'));\r\n```\r\n\r\nThe above will output: \r\n```\r\n[ [ '[start]', '[start]', '[start]', 'some' ],\r\n  [ '[start]', '[start]', 'some', 'other' ],\r\n  [ '[start]', 'some', 'other', 'words' ],\r\n  [ 'some', 'other', 'words', 'here' ],\r\n  [ 'other', 'words', 'here', 'for' ],\r\n  [ 'words', 'here', 'for', 'you' ],\r\n  [ 'here', 'for', 'you', '[end]' ],\r\n  [ 'for', 'you', '[end]', '[end]' ],\r\n  [ 'you', '[end]', '[end]', '[end]' ] ]\r\n```\r\n\r\nFor only end symbols, pass `null` for the start symbol, for instance:\r\n```javascript\r\nconsole.log(NGrams.ngrams('some other words here for you', 4, null, '[end]'));\r\n```\r\n\r\nWill output: \r\n```\r\n[ [ 'some', 'other', 'words', 'here' ],\r\n  [ 'other', 'words', 'here', 'for' ],\r\n  [ 'words', 'here', 'for', 'you' ],\r\n  [ 'here', 'for', 'you', '[end]' ],\r\n  [ 'for', 'you', '[end]', '[end]' ],\r\n  [ 'you', '[end]', '[end]', '[end]' ] ]\r\n```\r\n\r\n### NGramsZH\r\n\r\nFor Chinese like languages, you can use NGramsZH to do a n-gram, and all apis are the same:\r\n\r\n```javascript\r\nvar NGramsZH = natural.NGramsZH;\r\nconsole.log(NGramsZH.bigrams('中文测试'));\r\nconsole.log(NGramsZH.bigrams(['中',  '文',  '测', '试']));\r\nconsole.log(NGramsZH.trigrams('中文测试'));\r\nconsole.log(NGramsZH.trigrams(['中',  '文', '测',  '试']));\r\nconsole.log(NGramsZH.ngrams('一个中文测试', 4));\r\nconsole.log(NGramsZH.ngrams(['一', '个', '中', '文', '测',\r\n    '试'], 4));\r\n```\r\n\r\ntf-idf\r\n-----\r\n\r\n[Term Frequency–Inverse Document Frequency (tf-idf)](http://en.wikipedia.org/wiki/Tf%E2%80%93idf) is implemented to determine how important a word (or words) is to a \r\ndocument relative to a corpus. The following example will add four documents to \r\na corpus and determine the weight of the word \"node\" and then the weight of the \r\nword \"ruby\" in each document.\r\n\r\n```javascript\r\nvar natural = require('natural'),\r\n    TfIdf = natural.TfIdf,\r\n    tfidf = new TfIdf();\r\n\r\ntfidf.addDocument('this document is about node.');\r\ntfidf.addDocument('this document is about ruby.');\r\ntfidf.addDocument('this document is about ruby and node.');\r\ntfidf.addDocument('this document is about node. it has node examples');\r\n\r\nconsole.log('node --------------------------------');\r\ntfidf.tfidfs('node', function(i, measure) {\r\n    console.log('document #' + i + ' is ' + measure);\r\n});\r\n\r\nconsole.log('ruby --------------------------------');\r\ntfidf.tfidfs('ruby', function(i, measure) {\r\n    console.log('document #' + i + ' is ' + measure);\r\n});\r\n```\r\n\r\nThe above outputs:\r\n\r\n```\r\nnode --------------------------------\r\ndocument #0 is 1.4469189829363254\r\ndocument #1 is 0\r\ndocument #2 is 1.4469189829363254\r\ndocument #3 is 2.8938379658726507\r\nruby --------------------------------\r\ndocument #0 is 0\r\ndocument #1 is 1.466337068793427\r\ndocument #2 is 1.466337068793427\r\ndocument #3 is 0\r\n```\r\n\r\nThis approach can also be applied to individual documents.\r\n\r\nThe following example measures the term \"node\" in the first and second documents.\r\n\r\n```javascript\r\nconsole.log(tfidf.tfidf('node', 0));\r\nconsole.log(tfidf.tfidf('node', 1));\r\n```\r\n\r\nA TfIdf instance can also load documents from files on disk.\r\n\r\n```javascript\r\nvar tfidf = new TfIdf();\r\ntfidf.addFileSync('data_files/one.txt');\r\ntfidf.addFileSync('data_files/two.txt');\r\n```\r\n\r\nMultiple terms can be measured as well, with their weights being added into\r\na single measure value. The following example determines that the last document\r\nis the most relevant to the words \"node\" and \"ruby\".\r\n\r\n```javascript\r\nvar natural = require('natural'),\r\n    TfIdf = natural.TfIdf,\r\n    tfidf = new TfIdf();\r\n\r\ntfidf.addDocument('this document is about node.');\r\ntfidf.addDocument('this document is about ruby.');\r\ntfidf.addDocument('this document is about ruby and node.');\r\n\r\ntfidf.tfidfs('node ruby', function(i, measure) {\r\n    console.log('document #' + i + ' is ' + measure);\r\n});\r\n```\r\n\r\nThe above outputs:\r\n\r\n```\r\ndocument #0 is 1.2039728043259361\r\ndocument #1 is 1.2039728043259361\r\ndocument #2 is 2.4079456086518722\r\n```\r\n\r\nThe examples above all use strings, which case natural to automatically tokenize the input.\r\nIf you wish to perform your own tokenization or other kinds of processing, you\r\ncan do so, then pass in the resultant arrays later. This approach allows you to bypass natural's \r\ndefault preprocessing.\r\n\r\n```javascript\r\nvar natural = require('natural'),\r\n    TfIdf = natural.TfIdf,\r\n    tfidf = new TfIdf();\r\n\r\ntfidf.addDocument(['document', 'about', 'node']);\r\ntfidf.addDocument(['document', 'about', 'ruby']);\r\ntfidf.addDocument(['document', 'about', 'ruby', 'node']);\r\ntfidf.addDocument(['document', 'about', 'node', 'node', 'examples']);\r\n\r\ntfidf.tfidfs(['node', 'ruby'], function(i, measure) {\r\n    console.log('document #' + i + ' is ' + measure);\r\n});\r\n```\r\n\r\nIt's possible to retrieve a list of all terms in a document, sorted by their\r\nimportance.\r\n\r\n```javascript\r\ntfidf.listTerms(0 /*document index*/).forEach(function(item) {\r\n    console.log(item.term + ': ' + item.tfidf);\r\n});\r\n```\r\n\r\nA TfIdf instance can also be serialized and deserialized for save and recall.\r\n\r\n```javascript\r\nvar tfidf = new TfIdf();\r\ntfidf.addDocument('document one', 'un');\r\ntfidf.addDocument('document Two', 'deux');\r\nvar s = JSON.stringify(tfidf);\r\n// save \"s\" to disk, database or otherwise\r\n\r\n// assuming you pulled \"s\" back out of storage.\r\nvar tfidf = new TfIdf(JSON.parse(s));\r\n```\r\n\r\nTries\r\n-----\r\n\r\nTries are a very efficient data structure used for prefix-based searches. \r\nNatural comes packaged with a basic Trie implementation which can support match collection along a path,\r\nexistence search and prefix search.\r\n\r\n### Building The Trie\r\n\r\nYou need to add words to build up the dictionary of the Trie, this is an example of basic Trie set up:\r\n\r\n```javascript\r\nvar natural = require('natural'),\r\n    Trie = natural.Trie;\r\n\r\nvar trie = new Trie();\r\n\r\n// Add one string at a time\r\ntrie.addString(\"test\");\r\n\r\n// Or add many strings\r\ntrie.addStrings([\"string1\", \"string2\", \"string3\"]);\r\n```\r\n\r\n### Searching\r\n\r\n#### Contains\r\n\r\nThe most basic operation on a Trie is to see if a search string is marked as a word in the Trie.\r\n\r\n```javascript\r\nconsole.log(trie.contains(\"test\")); // true\r\nconsole.log(trie.contains(\"asdf\")); // false\r\n```\r\n\r\n### Find Prefix\r\n\r\nThe find prefix search will find the longest prefix that is identified as a word in the trie.\r\nIt will also return the remaining portion of the string which it was not able to match.\r\n\r\n```javascript\r\nconsole.log(trie.findPrefix(\"tester\"));     // ['test', 'er']\r\nconsole.log(trie.findPrefix(\"string4\"));    // [null, '4']\r\nconsole.log(trie.findPrefix(\"string3\"));    // ['string3', '']\r\n```\r\n\r\n### All Prefixes on Path\r\n\r\nThis search will return all prefix matches along the search string path.\r\n\r\n```javascript\r\ntrie.addString(\"tes\");\r\ntrie.addString(\"est\");\r\nconsole.log(trie.findMatchesOnPath(\"tester\")); // ['tes', 'test'];\r\n```\r\n\r\n### All Keys with Prefix\r\n\r\nThis search will return all of the words in the Trie with the given prefix, or [ ] if not found.\r\n\r\n```javascript\r\nconsole.log(trie.keysWithPrefix(\"string\")); // [\"string1\", \"string2\", \"string3\"]\r\n```\r\n\r\n### Case-Sensitivity\r\n\r\nBy default the trie is case-sensitive, you can use it in case-_in_sensitive mode by passing `false` \r\nto the Trie constructor.\r\n\r\n```javascript\r\ntrie.contains(\"TEST\"); // false\r\n\r\nvar ciTrie = new Trie(false);\r\nciTrie.addString(\"test\");\r\nciTrie.contains(\"TEsT\"); // true\r\n```\r\nIn the case of the searches which return strings, all strings returned will be in lower case if you are in case-_in_sensitive mode.\r\n\r\nEdgeWeightedDigraph\r\n-------------------\r\nEdgeWeightedDigraph represents a digraph, you can add an edge, get the number vertexes, edges, get all edges and use toString to print the Digraph.\r\n\r\ninitialize a digraph:\r\n\r\n```javascript\r\nvar EdgeWeightedDigraph = natural.EdgeWeightedDigraph;\r\nvar digraph = new EdgeWeightedDigraph();\r\ndigraph.add(5,4,0.35);\r\ndigraph.add(5,1,0.32);\r\ndigraph.add(1,3,0.29);\r\ndigraph.add(6,2,0.40);\r\ndigraph.add(3,6,0.52);\r\ndigraph.add(6,4,0.93);\r\n```\r\nthe api used is: add(from, to, weight).\r\n\r\nget the number of vertexes:\r\n\r\n```javascript\r\nconsole.log(digraph.v());\r\n```\r\nyou will get 5.\r\n\r\nget the number of edges:\r\n\r\n```javascript\r\nconsole.log(digraph.e());\r\n```\r\nyou will get 5.\r\n\r\n\r\n\r\nShortestPathTree\r\n----------------\r\n\r\nShortestPathTree represents a data type for solving the single-source shortest paths problem in\r\nedge-weighted directed acyclic graphs (DAGs).\r\nThe edge weights can be positive, negative, or zero. There are three APIs:\r\ngetDistTo(vertex),\r\nhasPathTo(vertex),\r\npathTo(vertex).\r\n\r\n```javascript\r\nvar ShortestPathTree = natural.ShortestPathTree;\r\nvar spt = new ShortestPathTree(digraph, 5);\r\n```\r\ndigraph is an instance of EdgeWeightedDigraph, the second param is the start vertex of DAG.\r\n\r\n### getDistTo(vertex)\r\n\r\nWill return the dist to vertex.\r\n\r\n```javascript\r\nconsole.log(spt.getDistTo(4));\r\n```\r\nthe output will be: 0.35\r\n\r\n### hasDistTo(vertex)\r\n\r\n```javascript\r\nconsole.log(spt.hasDistTo(4));\r\nconsole.log(spt.hasDistTo(5));\r\n```\r\n\r\noutput will be:\r\n\r\n```javascript\r\ntrue\r\nfalse\r\n```\r\n\r\n### pathTo(vertex)\r\nthis will return a shortest path:\r\n\r\n```javascript\r\nconsole.log(spt.pathTo(4));\r\n```\r\n\r\noutput will be:\r\n\r\n```javascript\r\n[5, 4]\r\n```\r\n\r\nLongestPathTree\r\n----------------\r\n\r\nLongestPathTree represents a data type for solving the single-source shortest paths problem in\r\nedge-weighted directed acyclic graphs (DAGs).\r\nThe edge weights can be positive, negative, or zero. There are three APIs same as ShortestPathTree:\r\ngetDistTo(vertex),\r\nhasPathTo(vertex),\r\npathTo(vertex).\r\n\r\n```javascript\r\nvar ShortestPathTree = natural.ShortestPathTree;\r\nvar spt = new ShortestPathTree(digraph, 5);\r\n```\r\ndigraph is an instance of EdgeWeightedDigraph, the second param is the start vertex of DAG.\r\n\r\n### getDistTo(vertex)\r\n\r\nWill return the dist to vertex.\r\n\r\n```javascript\r\nconsole.log(spt.getDistTo(4));\r\n```\r\nthe output will be: 2.06\r\n\r\n### hasDistTo(vertex)\r\n\r\n```javascript\r\nconsole.log(spt.hasDistTo(4));\r\nconsole.log(spt.hasDistTo(5));\r\n```\r\n\r\noutput will be:\r\n\r\n```javascript\r\ntrue\r\nfalse\r\n```\r\n\r\n### pathTo(vertex)\r\nthis will return a shortest path:\r\n\r\n```javascript\r\nconsole.log(spt.pathTo(4));\r\n```\r\n\r\noutput will be:\r\n\r\n```javascript\r\n[5, 1, 3, 6, 4]\r\n```\r\n\r\nWordNet\r\n-------\r\n\r\nOne of the newest and most experimental features in natural is WordNet integration. Here's an\r\nexample of using natural to look up definitions of the word node. To use the WordNet module,\r\nfirst install the WordNet database files using the [WNdb module](https://github.com/moos/WNdb):\r\n\r\n    npm install WNdb\r\n\r\n(For node < v0.6, please use 'npm install WNdb@3.0.0')\r\n\r\nKeep in mind that the WordNet integration is to be considered experimental at this point,\r\nand not production-ready. The API is also subject to change.\r\n\r\nHere's an example of looking up definitions for the word, \"node\".\r\n\r\n```javascript\r\nvar wordnet = new natural.WordNet();\r\n\r\nwordnet.lookup('node', function(results) {\r\n    results.forEach(function(result) {\r\n        console.log('------------------------------------');\r\n        console.log(result.synsetOffset);\r\n        console.log(result.pos);\r\n        console.log(result.lemma);\r\n        console.log(result.synonyms);\r\n        console.log(result.pos);\r\n        console.log(result.gloss);\r\n    });\r\n});\r\n```\r\n\r\nGiven a synset offset and a part of speech, a definition can be looked up directly.\r\n\r\n```javascript\r\nvar wordnet = new natural.WordNet();\r\n\r\nwordnet.get(4424418, 'n', function(result) {\r\n    console.log('------------------------------------');\r\n    console.log(result.lemma);\r\n    console.log(result.pos);\r\n    console.log(result.gloss);\r\n    console.log(result.synonyms);\r\n});\r\n```\r\n\r\nIf you have _manually_ downloaded the WordNet database files, you can pass the folder to the constructor:\r\n\r\n```javascript\r\nvar wordnet = new natural.WordNet('/my/wordnet/dict');\r\n```\r\n\r\nAs of v0.1.11, WordNet data files are no longer automatically downloaded.\r\n\r\nPrinceton University \"About WordNet.\" WordNet. Princeton University. 2010. <http://wordnet.princeton.edu>\r\n\r\nSpellcheck\r\n------------\r\nA probabilistic spellchecker based on http://norvig.com/spell-correct.html\r\n\r\nThis is best constructed with an array of tokens from a corpus, but a simple list of words from a dictionary will work. \r\n\r\n```javascript\r\nvar corpus = ['something', 'soothing'];\r\nvar spellcheck = new Spellcheck(corpus);\r\n```\r\n\r\nIt uses the trie datastructure for fast boolean lookup of a word\r\n\r\n```javascript\r\nspellcheck.isCorrect('cat'); // false\r\n```\r\n\r\nIt suggests corrections (sorted by probability in descending order) that are up to a maximum edit distance away from the input word. According to Norvig, a max distance of 1 will cover 80% to 95% of spelling mistakes. After a distance of 2, it becomes very slow.\r\n\r\n```javascript\r\nspellcheck.getCorrections('soemthing', 1); // ['something']\r\nspellcheck.getCorrections('soemthing', 2); // ['something', 'soothing']\r\n```\r\n\r\n\r\nDevelopment\r\n-----------\r\nWhen developing, please:\r\n\r\n+ Write unit tests\r\n+ Make sure your unit tests pass\r\n\r\nThe current configuration of the unit tests requires the following environment variable to be set:\r\n\r\n    export NODE_PATH=.\r\n\r\n\r\nLicense\r\n-------\r\n\r\nCopyright (c) 2011, 2012 Chris Umbel, Rob Ellis, Russell Mull\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n\r\nWordNet License\r\n---------------\r\n\r\nThis license is available as the file LICENSE in any downloaded version of WordNet.\r\nWordNet 3.0 license: (Download)\r\n\r\nWordNet Release 3.0 This software and database is being provided to you, the LICENSEE, by Princeton University under the following license. By obtaining, using and/or copying this software and database, you agree that you have read, understood, and will comply with these terms and conditions.: Permission to use, copy, modify and distribute this software and database and its documentation for any purpose and without fee or royalty is hereby granted, provided that you agree to comply with the following copyright notice and statements, including the disclaimer, and that the same appear on ALL copies of the software, database and documentation, including modifications that you make for internal use or for distribution. WordNet 3.0 Copyright 2006 by Princeton University. All rights reserved. THIS SOFTWARE AND DATABASE IS PROVIDED \"AS IS\" AND PRINCETON UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PRINCETON UNIVERSITY MAKES NO REPRESENTATIONS OR WARRANTIES OF MERCHANT- ABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE LICENSED SOFTWARE, DATABASE OR DOCUMENTATION WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS, TRADEMARKS OR OTHER RIGHTS. The name of Princeton University or Princeton may not be used in advertising or publicity pertaining to distribution of the software and/or database. Title to copyright in this software, database and any associated documentation shall at all times remain with Princeton University and LICENSEE agrees to preserve same.\r\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/NaturalNode/natural/issues"
  },
  "_id": "natural@0.2.1",
  "_shasum": "88229a6dabc0b5489145040dabb2cf29d894c861",
  "_from": "git://github.com/NaturalNode/natural.git",
  "_resolved": "git://github.com/NaturalNode/natural.git#7621accaa19abf5bc8140c81c9ec4db0a00ff5f8"
}
